{"version":3,"file":"mosella.umd.js","sources":["../src/stream.js","../src/operator.js","../src/filter.js","../src/pipe.js","../src/map.js","../src/sum.js","../src/merge.js","../src/combine.js"],"sourcesContent":["export const STREAM = \"MOSELLA_STREAM\";\r\nexport const STOP = \"MOSELLA_STOP\";\r\nexport const RESET = \"MOSELLA_RESET\";\r\nexport const stream = currentValue => {\r\n  const listeners = [];\r\n  let queuedValues = [];\r\n  if (currentValue !== undefined) {\r\n    queuedValues.push(currentValue);\r\n  }\r\n  const initialValue = currentValue;\r\n  let emitPromise;\r\n\r\n  const emit = (value, listeners) => {\r\n    const doEmit = () => {\r\n      if (listeners.length > 0) {\r\n        const result = listeners.shift()(value);\r\n        if (result instanceof Promise) {\r\n          return result.then(() => doEmit());\r\n        }\r\n        return doEmit();\r\n      }\r\n    };\r\n    return doEmit();\r\n  };\r\n\r\n  const queueEmit = (value, listeners) => {\r\n    listeners = [...listeners];\r\n    let promise;\r\n    const callEmit = () => {\r\n      if (emitPromise === promise) {\r\n        emitPromise = undefined;\r\n      }\r\n      const result = emit(value, listeners);\r\n      if (result instanceof Promise) {\r\n        emitPromise = result;\r\n      }\r\n    };\r\n    if (emitPromise) {\r\n      promise = emitPromise.then(callEmit);\r\n      emitPromise = promise;\r\n    } else {\r\n      callEmit();\r\n    }\r\n  };\r\n\r\n  const stream$ = function(value) {\r\n    if (currentValue !== STOP && value !== undefined) {\r\n      if (value !== undefined) {\r\n        currentValue = value;\r\n      }\r\n      if (value === RESET) {\r\n        currentValue = initialValue;\r\n        queuedValues = [];\r\n      }\r\n      if (listeners.length > 0) {\r\n        queueEmit(value, listeners);\r\n      } else if (value !== RESET) {\r\n        queuedValues.push(value);\r\n      }\r\n      if (value === STOP) {\r\n        listeners.length = 0;\r\n        queuedValues.length = 0;\r\n      }\r\n    }\r\n    return currentValue;\r\n  };\r\n\r\n  stream$.on = listener => {\r\n    if (currentValue !== STOP) {\r\n      listeners.push(listener);\r\n      if (queuedValues.length > 0) {\r\n        queuedValues = queuedValues.filter(value => {\r\n          queueEmit(value, listeners);\r\n          return false;\r\n        });\r\n      }\r\n      return () => {\r\n        listeners.splice(listeners.indexOf(listener), 1);\r\n      };\r\n    }\r\n  };\r\n\r\n  stream$.stop = () => {\r\n    stream$(STOP);\r\n  };\r\n\r\n  stream$.reset = () => {\r\n    stream$(RESET);\r\n  };\r\n\r\n  stream$.hasListeners = () => listeners.length > 0;\r\n\r\n  stream$.is = STREAM;\r\n\r\n  return stream$;\r\n};\r\n","import { stream, STREAM, STOP, RESET } from \"./stream\";\r\n\r\nconst wrapStream = (op, args, streamIn$) => {\r\n  const stream$ = streamIn$ || args.pop();\r\n  const valueStream$ = stream();\r\n  let outStream$;\r\n  stream$.on(value => {\r\n    if (value !== STOP && value !== RESET) {\r\n      valueStream$(value);\r\n    } else {\r\n      outStream$(value);\r\n    }\r\n  });\r\n  outStream$ = op.apply(op, [...args, valueStream$]);\r\n  return outStream$;\r\n};\r\n\r\nexport const operator = op => {\r\n  return (...args) => {\r\n    const lastArg = args[args.length - 1];\r\n    if (typeof lastArg === \"function\" && lastArg.is === STREAM) {\r\n      return wrapStream(op, args);\r\n    } else {\r\n      return stream$ => wrapStream(op, args, stream$);\r\n    }\r\n  };\r\n};\r\n","import { operator } from \"./operator\";\r\nimport { stream } from \"./stream\";\r\nexport const filter = operator((predicate, stream$) => {\r\n  const newStream$ = stream();\r\n  stream$.on(value => {\r\n    let shouldEmit = predicate(value);\r\n    if (shouldEmit instanceof Promise) {\r\n      shouldEmit.then(v => {\r\n        if (shouldEmit) {\r\n          newStream$(value);\r\n        }\r\n      });\r\n    } else {\r\n      if (shouldEmit) {\r\n        newStream$(value);\r\n      }\r\n    }\r\n    return shouldEmit;\r\n  });\r\n  return newStream$;\r\n});\r\n","import { operator } from \"./operator\";\r\nexport const pipe = operator((...operators) => {\r\n  let stream$ = operators.pop();\r\n  for (const operator of operators) {\r\n    stream$ = operator(stream$);\r\n  }\r\n  return stream$;\r\n});\r\n","import { operator } from \"./operator\";\r\nimport { stream } from \"./stream\";\r\nexport const map = operator((cb, stream$) => {\r\n  const newStream$ = stream();\r\n  stream$.on(value => {\r\n    let mappedValue = cb.apply(cb, [value]);\r\n    if (mappedValue instanceof Promise) {\r\n      mappedValue.then(v => newStream$(v));\r\n    } else {\r\n      newStream$(mappedValue);\r\n    }\r\n    return mappedValue;\r\n  });\r\n  return newStream$;\r\n});\r\n","import { map } from \"./map\";\n\nexport const sum = map(function(value) {\n  if (this.sum === undefined) {\n    this.sum = 0;\n  }\n  return (this.sum += value);\n});\n","import { stream } from \"./stream\";\nexport const merge = (...streams$) => {\n  const newStream$ = stream();\n  for (const stream$ of streams$) {\n    stream$.on(value => newStream$(value));\n  }\n  return newStream$;\n};\n","import { stream, RESET, STOP } from \"./stream\";\nexport const combine = (...streams$) => {\n  const values = Array(streams$.length).fill(undefined);\n\n  streams$.forEach((stream$, index) => {\n    values[index] = stream$();\n  });\n\n  const newStream$ = stream(values);\n  streams$.forEach((stream$, index) => {\n    stream$.on(value => {\n      if (value === RESET || value === STOP) {\n        newStream$(value);\n      } else {\n        values[index] = value;\n        newStream$([...values]);\n      }\n    });\n  });\n  return newStream$;\n};\n"],"names":["const","STOP","RESET","stream","currentValue","listeners","queuedValues","undefined","push","emitPromise","initialValue","queueEmit","value","promise","callEmit","result","doEmit","length","shift","Promise","then","emit","stream$","on","listener","filter","splice","indexOf","stop","reset","hasListeners","is","wrapStream","op","args","streamIn$","outStream$","pop","valueStream$","apply","operator","lastArg","predicate","newStream$","shouldEmit","v","pipe","operators","map","cb","mappedValue","sum","this","streams$","values","Array","fill","forEach","index"],"mappings":"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"}