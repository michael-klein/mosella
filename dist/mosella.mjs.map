{"version":3,"file":"mosella.mjs","sources":["../src/stream.js","../src/operator.js","../src/filter.js","../src/pipe.js","../src/map.js","../src/merge.js","../src/sum.js","../src/combine.js"],"sourcesContent":["export const STREAM = Symbol(\"stream\");\r\nexport const STOP = Symbol(\"stop\");\r\nexport const stream = currentValue => {\r\n  const listeners = [];\r\n  let queuedValues = [];\r\n  if (currentValue !== undefined) {\r\n    queuedValues.push(currentValue);\r\n  }\r\n  let emitPromise;\r\n\r\n  const emit = (value, listeners) => {\r\n    const doEmit = () => {\r\n      if (listeners.length > 0) {\r\n        const result = listeners.shift()(value);\r\n        if (result instanceof Promise) {\r\n          return result.then(() => doEmit());\r\n        }\r\n        return doEmit();\r\n      }\r\n    };\r\n    return doEmit();\r\n  };\r\n\r\n  const queueEmit = (value, listeners) => {\r\n    listeners = [...listeners];\r\n    let promise;\r\n    const callEmit = () => {\r\n      if (emitPromise === promise) {\r\n        emitPromise = undefined;\r\n      }\r\n      const result = emit(value, listeners);\r\n      if (result instanceof Promise) {\r\n        emitPromise = result;\r\n      }\r\n    };\r\n    if (emitPromise) {\r\n      promise = emitPromise.then(callEmit);\r\n      emitPromise = promise;\r\n    } else {\r\n      callEmit();\r\n    }\r\n  };\r\n\r\n  const stream$ = function(value) {\r\n    if (currentValue !== STOP) {\r\n      if (value !== undefined) {\r\n        currentValue = value;\r\n      }\r\n      if (listeners.length > 0) {\r\n        queueEmit(value, listeners);\r\n      } else {\r\n        queuedValues.push(value);\r\n      }\r\n      if (value === STOP) {\r\n        listeners.length = 0;\r\n        queuedValues.length = 0;\r\n      }\r\n    }\r\n    return currentValue;\r\n  };\r\n\r\n  stream$.on = listener => {\r\n    if (currentValue !== STOP) {\r\n      listeners.push(listener);\r\n      if (queuedValues.length > 0) {\r\n        queuedValues = queuedValues.filter(value => {\r\n          queueEmit(value, listeners);\r\n          return false;\r\n        });\r\n      }\r\n      return () => {\r\n        listeners.splice(listeners.indexOf(listener), 1);\r\n      };\r\n    }\r\n  };\r\n\r\n  stream$.stop = () => {\r\n    stream$(STOP);\r\n  };\r\n\r\n  stream$.hasListeners = () => listeners.length > 0;\r\n\r\n  stream$.is = STREAM;\r\n\r\n  return stream$;\r\n};\r\n","import { stream, STREAM, STOP } from \"./stream\";\r\n\r\nconst wrapStream = (op, args, streamIn$) => {\r\n  const stream$ = streamIn$ || args.pop();\r\n  const valueStream$ = stream();\r\n  let outStream$;\r\n  stream$.on(value => {\r\n    if (value !== STOP) {\r\n      valueStream$(value);\r\n    } else {\r\n      outStream$(value);\r\n    }\r\n  });\r\n  outStream$ = op.apply(op, [...args, valueStream$]);\r\n  return outStream$;\r\n};\r\n\r\nexport const operator = op => {\r\n  return (...args) => {\r\n    const lastArg = args[args.length - 1];\r\n    if (typeof lastArg === \"function\" && lastArg.is === STREAM) {\r\n      return wrapStream(op, args);\r\n    } else {\r\n      return stream$ => wrapStream(op, args, stream$);\r\n    }\r\n  };\r\n};\r\n","import { operator } from \"./operator\";\r\nimport { stream } from \"./stream\";\r\nexport const filter = operator((predicate, stream$) => {\r\n  const newStream$ = stream();\r\n  stream$.on(value => {\r\n    let shouldEmit = predicate(value);\r\n    if (shouldEmit instanceof Promise) {\r\n      shouldEmit.then(v => {\r\n        if (shouldEmit) {\r\n          newStream$(value);\r\n        }\r\n      });\r\n    } else {\r\n      if (shouldEmit) {\r\n        newStream$(value);\r\n      }\r\n    }\r\n    return shouldEmit;\r\n  });\r\n  return newStream$;\r\n});\r\n","import { operator } from \"./operator\";\r\nexport const pipe = operator((...operators) => {\r\n  let stream$ = operators.pop();\r\n  for (const operator of operators) {\r\n    stream$ = operator(stream$);\r\n  }\r\n  return stream$;\r\n});\r\n","import { operator } from \"./operator\";\r\nimport { stream } from \"./stream\";\r\nexport const map = operator((cb, stream$) => {\r\n  const newStream$ = stream();\r\n  stream$.on(value => {\r\n    let mappedValue = cb.apply(cb, [value]);\r\n    if (mappedValue instanceof Promise) {\r\n      mappedValue.then(v => newStream$(v));\r\n    } else {\r\n      newStream$(mappedValue);\r\n    }\r\n    return mappedValue;\r\n  });\r\n  return newStream$;\r\n});\r\n","import { stream } from \"./stream\";\nexport const merge = (...streams$) => {\n  const newStream$ = stream();\n  for (const stream$ of streams$) {\n    stream$.on(value => newStream$(value));\n  }\n  return newStream$;\n};\n","import { map } from \"./map\";\n\nexport const sum = map(function(value) {\n  if (this.sum === undefined) {\n    this.sum = 0;\n  }\n  return (this.sum += value);\n});\n","import { stream } from \"./stream\";\nexport const combine = (...streams$) => {\n  const values = Array(streams$.length).fill(undefined);\n  const newStream$ = stream();\n\n  streams$.forEach((stream$, index) => {\n    values[index] = stream$();\n  });\n  newStream$(values);\n  streams$.forEach((stream$, index) => {\n    stream$.on(value => {\n      values[index] = value;\n      newStream$(values);\n    });\n  });\n  return newStream$;\n};\n"],"names":["const","STREAM","Symbol","STOP","stream","currentValue","emitPromise","listeners","queuedValues","undefined","push","queueEmit","value","promise","callEmit","result","doEmit","length","shift","Promise","then","emit","stream$","on","listener","filter","splice","indexOf","stop","hasListeners","is","wrapStream","op","args","streamIn$","outStream$","pop","valueStream$","apply","operator","lastArg","predicate","newStream$","shouldEmit","v","pipe","operators","map","cb","mappedValue","merge","streams$","sum","this","combine","values","Array","fill","forEach","index"],"mappings":"AAAOA,IAAMC,EAASC,OAAO,UAChBC,EAAOD,OAAO,QACdE,WAASC,OAMhBC,EALEC,EAAY,GACdC,EAAe,QACEC,IAAjBJ,GACFG,EAAaE,KAAKL,OAiBdM,WAAaC,EAAOL,OAEpBM,EADJN,EAAY,UAAIA,OAEVO,aACAR,IAAgBO,IAClBP,OAAcG,OAEVM,WApBIH,EAAOL,OACbS,gBACAT,EAAUU,OAAS,EAAG,KAClBF,EAASR,EAAUW,OAAVX,CAAkBK,UAC7BG,aAAkBI,QACbJ,EAAOK,uBAAWJ,MAEpBA,aAGJA,IAUUK,CAAKT,EAAOL,GACvBQ,aAAkBI,UACpBb,EAAcS,IAGdT,GACFO,EAAUP,EAAYc,KAAKN,GAC3BR,EAAcO,GAEdC,KAIEQ,EAAU,SAASV,UACnBP,IAAiBF,SACLM,IAAVG,IACFP,EAAeO,GAEbL,EAAUU,OAAS,EACrBN,EAAUC,EAAOL,GAEjBC,EAAaE,KAAKE,GAEhBA,IAAUT,IACZI,EAAUU,OAAS,EACnBT,EAAaS,OAAS,IAGnBZ,UAGTiB,EAAQC,YAAKC,MACPnB,IAAiBF,SACnBI,EAAUG,KAAKc,GACXhB,EAAaS,OAAS,IACxBT,EAAeA,EAAaiB,gBAAOb,UACjCD,EAAUC,EAAOL,IACV,gBAITA,EAAUmB,OAAOnB,EAAUoB,QAAQH,GAAW,KAKpDF,EAAQM,gBACNN,EAAQnB,IAGVmB,EAAQO,+BAAqBtB,EAAUU,OAAS,GAEhDK,EAAQQ,GAAK7B,EAENqB,GClFHS,WAAcC,EAAIC,EAAMC,OAGxBC,EAFEb,EAAUY,GAAaD,EAAKG,MAC5BC,EAAejC,WAErBkB,EAAQC,YAAGX,GACLA,IAAUT,EACZkC,EAAazB,GAEbuB,EAAWvB,KAGfuB,EAAaH,EAAGM,MAAMN,EAAQC,UAAMI,MAIzBE,WAAWP,gFAEdQ,EAAUP,EAAKA,EAAKhB,OAAS,SACZ,mBAAZuB,GAA0BA,EAAQV,KAAO7B,EAC3C8B,EAAWC,EAAIC,YAEfX,UAAWS,EAAWC,EAAIC,EAAMX,MCrBhCG,EAASc,WAAUE,EAAWnB,OACnCoB,EAAatC,WACnBkB,EAAQC,YAAGX,OACL+B,EAAaF,EAAU7B,UACvB+B,aAAsBxB,QACxBwB,EAAWvB,cAAKwB,GACVD,GACFD,EAAW9B,KAIX+B,GACFD,EAAW9B,GAGR+B,IAEFD,IClBIG,EAAON,4EACdjB,EAAUwB,EAAUV,YACDU,kBACrBxB,GAAUiB,QAASjB,UAEdA,ICJIyB,EAAMR,WAAUS,EAAI1B,OACzBoB,EAAatC,WACnBkB,EAAQC,YAAGX,OACLqC,EAAcD,EAAGV,MAAMU,EAAI,CAACpC,WAC5BqC,aAAuB9B,QACzB8B,EAAY7B,cAAKwB,UAAKF,EAAWE,KAEjCF,EAAWO,GAENA,IAEFP,ICZIQ,4EACLR,EAAatC,UACG+C,uBACZ5B,YAAGX,UAAS8B,EAAW9B,YAE1B8B,GCJIU,EAAML,EAAI,SAASnC,eACbH,IAAb4C,KAAKD,WACFA,IAAM,GAELC,KAAKD,KAAOxC,ICLT0C,wEACLC,EAASC,MAAML,EAASlC,QAAQwC,UAAKhD,GACrCiC,EAAatC,WAEnB+C,EAASO,iBAASpC,EAASqC,GACzBJ,EAAOI,GAASrC,MAElBoB,EAAWa,GACXJ,EAASO,iBAASpC,EAASqC,GACzBrC,EAAQC,YAAGX,GACT2C,EAAOI,GAAS/C,EAChB8B,EAAWa,OAGRb"}